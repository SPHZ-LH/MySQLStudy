30、索引

    30.1什么是索引？
        索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。
        一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。
        索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。

        对于一本字典来说，查找某个汉字有两种方式：
            第一种方式：一页一页挨着找，直到找到为止，这种查询方式属于全字段扫描。
            效率比较低。
            第二种方式：先扫描目录（索引）去定位一个大概的位置，然后直接定位到这个
            位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过
            索引查索，效率较高。

        t_user
        id(idIndex) name(nameIndex)   email(emailIndex)  address(emailAddressIndex)
        ----------------------------------------------------------------------------
        1           zhangsan...
        2           lisi
        3           wangwu
        4           zhaoliu
        5           hanmeimei
        6           jack

        select * from t_user where name = 'jack';

        以上的这条SQL语句会去name字段上扫描，为什么？
            因为查询条件是：name = 'jack'
        
        如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，
        MySQL会进行全扫描，会将name字段上的每一个都比对一遍。效率比较低。

        MySQL在查询方面主要就是两种方式：
            第一种方式：全表扫描
            第二种方式：根据索引扫描

        注意：
            在实际中，汉语字典前面的目录是排序的，按照a b c d e f ......排序，
            为什么排序呢？因为只有排序了才会有区间查找这一说！（缩小扫描范围
            其实就是为了扫描某个区间罢了！）

            在mysql数据库当中索引也是需要排序的，并且这个索引的排序和TreeSet
            数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql
            当中索引是一个B-Tree数据结构。

             遵顼左小右大原则存放。采用中序遍历方式遍历取数据。

    30.2、索引的实现原理？

        假设有一张用户表：t_user

        id(PK)              name                每一行记录在硬盘上都有物理存储编号
        -----------------------------------------------------------------------
        100                 zhangsan            0x1111
        120                 lisi                0x2222
        99                  wangwu              0x8888
        88                  zhaoliu             0x9999
        101                 jack                0x6666
        55                  lucy                0x5555
        130                 tom                 0x7777

        提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，
        因为id是PK。另外mysql当中，一个字段上如果有unique约束的化，也会自动
        创建索引对象。

        提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有
        一个硬盘的物理存储编号。

        提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式
        存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中
        索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引
        被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个数的形式
        存在。（自平衡二叉树：B-Tree）

    30.3、在mysql当中，主键上，以及unique字段上都会自动添加索引！！！！
        什么条件下，我们会考虑给字段添加索引呢？
            条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）
            条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段宗师被扫描的。
            条件3：该字段很少的DML（insert delete update）操作。（因为DML之后，索引需要重新排序。）

            建议不要随便添加索引，因为索引也是需要维护的，太多的化反而会降低系统的性能。
            建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。

    30.4、索引怎么创建？怎么删除？语法是什么？
        创建索引：
            mysql> create index emp_ename_index on emp(ename);
            给emp表的ename字段添加索引，起名：emp_ename_index

        删除索引：
            mysql> drop index emp_ename_index on emp;
            给emp表上的emp_ename_index索引对象删除。

    30.5、在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索？

        mysql> explain select * from emp where ename = 'KING';
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
        | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
        |  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    10.00 | Using where |
        +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
        扫描14条记录：说明没有使用索引。type=ALL

        mysql> create index emp_ename_index on emp(ename);
        mysql> explain select * from emp where ename = 'KING';
        +----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
        | id | select_type | table | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra |
        +----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
        |  1 | SIMPLE      | emp   | NULL       | ref  | emp_ename_index | emp_ename_index | 43      | const |    1 |   100.00 | NULL  |
        +----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+

    30.6、索引有失效的时候，什么时候索引失效呢？

        失效的第1种情况：
            select * from emp where ename like '%T';

            ename上即使添加了索引，也不会走索引，为什么？
                原因是因为模糊匹配当中以"%"开头了！
                尽量避免模糊查询的时候"%"开始。
                这是一种优化的手段/策略。

            mysql> explain select * from emp where ename like '%T';
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
            | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    11.11 | Using where |
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+

        失效的第2种情况：
            使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有
            索引，才会走索引。如果其中一边有索引，另一边没有索引，那么另
            一个字段上的索引也会失效。所以这就是为什么不建议使用or的原因。

            mysql> explain select * from emp where ename = 'KING' or job = 'MANAGER';
            +----+-------------+-------+------------+------+-----------------+------+---------+------+------+----------+-------------+
            | id | select_type | table | partitions | type | possible_keys   | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-------+------------+------+-----------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | emp   | NULL       | ALL  | emp_ename_index | NULL | NULL    | NULL |   14 |    16.43 | Using where |
            +----+-------------+-------+------------+------+-----------------+------+---------+------+------+----------+-------------+

        失效的第3种情况：
            使用符合索引的时候，没有使用左侧的列查找，索引失效
            什么是复合索引？
                两个字段，或者多个字段联合起来添加一个索引，叫做复合索引。

            mysql> create index emp_job_sal_index on emp(job,sal);

            mysql> explain select * from emp where job = 'MANAGER';
            +----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+
            | id | select_type | table | partitions | type | possible_keys     | key               | key_len | ref   | rows | filtered | Extra |
            +----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+
            |  1 | SIMPLE      | emp   | NULL       | ref  | emp_job_sal_index | emp_job_sal_index | 39      | const |    3 |   100.00 | NULL  |
            +----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+

            mysql> explain select * from emp where sal = 800;
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
            | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |    10.00 | Using where |
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
        
        失效的第4种情况：
            在where当中索引列使用了函数
            mysql> explain select * from emp where lower(ename) = 'smith';
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
            | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
            |  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   14 |   100.00 | Using where |
            +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
        
        失效的第5...
        失效的第6...

    30.7、索引是各种数据库进行优化的重要手段。优化的时候优先考虑的因素就是索引。
        
        索引在数据库当中分了很多类？
            单一索引：一个字段添加索引。
            复合索引：两个字段或多个字段上添加索引。

            主键索引：主键上添加索引。
            唯一性索引：具有unique约束的字段上添加索引。
            ......

            注意：唯一性比较弱的字段上添加索引用处不大。